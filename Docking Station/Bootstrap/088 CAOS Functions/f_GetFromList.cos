**CAOS FUNCTION**

new: simp 1 202 1 "blank" 0 0 0
sets game "f_GetFromList" sorc 1 202 1 1000
setv game "f_GetFromList:v" 1

*clean yourself up-- remove the script, kill this agent
scrx 1 202 1 1000
kill targ

*Uncomment to test. It works!

*proof grouping by brackets works
*sets va88 "[cats,dogs,[fish,frogs],potatoes,tomatoes,constantly wishing,[a,b,c,d],1,2,3999]"
*outs caos 0 0 "l" va88 game "f_GetFromList" 0 0 va87

*sets va88 "[cats,dogs,[fish,frogs],potatoes,tomatoes,eem foo bibble]"
*sets va87 caos 0 0 3 va88 game "f_GetFromList" 0 0 va99
*outs caos 0 0 1 va87 game "f_GetFromList" 0 0 va99

*f_GetFromList
scrp 1 202 1 1000
*returns item _p1_ from _p2_
*returns "##?" if item not found
*_p1_ special cases: l - length/number of items, r, return a random item, 
	doif type _p1_ eq 0
		setv va97 _p1_
	endi

	doif type _p1_ eq 2
		doif lowa _p1_ eq "l"
			setv va97 -1
		elif lowa _p1_ eq "r"
			setv va97 rand 1 stoi caos 0 0 "l" _p2_ game "f_GetFromList" 0 0 va87
		endi
	endi

*first item:
	sets va99 _p2_
	sets va98 ","
	setv va50 1
	setv va54 1

**first if you got passed in a list you need to strip those brackets first alright?
	doif subs va99 va50 1 eq "["
		gsub CheckIfList
	endi

	loop
*va50 = slice start
*va51 = comma location
*va52 = slice length
*va53 = contents of slice
*va54 = which va we are on
*va55 = the param requested
		setv va51 sins va99 va50 va98
*there's no more commas
		doif va51 eq -1
*if you're the first one and there's no commas, you're the only parameter
			doif va54 eq 1 and va97 eq 1
				sets va55 va99
				gsub found
				stop
			else
*if you're not the first one and you're out of commas, you're the last parameter
				setv va52 -1
				doif va54 eq va97 and va50 lt strl va99
					sets va55 subs va99 va50 va52
					gsub found
					stop
*if va97 is -1, congrats, va54 should hold the length of your list.
				elif va97 eq -1
*one exception to this is that if your list ended with a list, you'll need to subtract one 
*because that means the last item already got counted
					doif subs va99 strl va99 1 eq "]"
						subv va54 1
					endi
					outs vtos va54
					stop

				endi
			endi
		else
			setv va52 va51
			subv va52 va50
*see if this param contains a bracket
			gsub AcknowledgeList
*if this is the one you are looking for, slice it!
			doif va54 eq va97
				sets va55 subs va99 va50 va52
				gsub found
				stop
			endi
			addv va50 va52
			addv va50 1
		endi

		addv va54 1

	untl va51 eq -1

	outs "##?"

	subr found
		outs va55
	retn

	subr AcknowledgeList
*if you find an opening bracket you have to set the "end" marker (va52) to the closing bracket
		doif subs va99 va50 1 eq "["
			setv va56 strl va99
			gsub CheckInList
		endi
	retn

	subr CheckIfList
*we already know it starts with a bracket so let's see if it ends with one
		doif subs va99 strl va99 1 eq "]"
*even if it does end with one we still Don't Know if it's actually encompassing the whole thing
*we have to check if there's an ending bracket before another beginning bracket
			gsub CheckInList
			doif va52 eq strl va99
*the whole item is in fact a list, so we need to break it out of that list
				setv va56 strl va99
				subv va56 2
				sets va99 subs va99 2 va56
			endi
		endi
	retn

	subr CheckInList
* For finding out when a list actually ends, accounting for lists-in-lists
* If I was more clever I feel like I would find a better solution for this 3:
* But this is what I got:

*	va50 -- Bracket start of current list
*	va52 -- to be set to length of list, eventually.
*	va59 -- "Is the bracket still open" flag. Loop ends when this is 0.
*	va60 -- position of last open bracket
*	va61 -- position of last close bracket
*	va62 -- position of currently-searching open bracket
*	va63 -- position of currently-searching close bracket

		setv va59 1
		setv va60 va50
		addv va60 1
		setv va61 va50
		loop
*search for a pair
			setv va63 sins va99 va61 "]"
			setv va62 sins va99 va60 "["
*if the closing bracket falls first, a close happens.
			doif va63 lt va62 or va62 eq -1
				subv va59 1
			endi
*if there IS NO CLOSE BRACKET, AT ALL there's a problem with the structure here
*so just end it to be safe
			doif va63 eq -1
				setv va59 0
				setv va63 strl va99
				subv va63 va50
			endi
*save your positions for the next round
			setv va61 va63
			addv va61 1
			setv va60 va62
			addv va60 1
*			dbg: outv va63
		untl va59 eq 0
*once va59 is 0, va61 holds the end of the current list
		setv va52 va61
		subv va52 va50
*		dbg: outv va50
*		dbg: outv va52

	retn

	subr getLength
	retn

endm

rscr
delg "f_GetFromList"
delg "f_GetFromList:v"